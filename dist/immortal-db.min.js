/*! For license information please see immortal-db.min.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ImmortalDB=t():e.ImmortalDB=t()}(self,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})}};e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var t={};e.r(t),e.d(t,{CookieStore:()=>d,DEFAULT_DATABASE_NAME:()=>_,DEFAULT_KEY_PREFIX:()=>k,DEFAULT_STORES:()=>x,DEFAULT_STORE_NAME:()=>y,DEFAULT_VALUE:()=>b,ImmortalDecoderError:()=>s,ImmortalEncoderError:()=>o,ImmortalError:()=>r,ImmortalStorage:()=>D,ImmortalStoresPartialError:()=>n,ImmortalStoresTotalError:()=>i,IndexedDbStore:()=>v,LocalStorageStore:()=>S,SessionStorageStore:()=>E});class r extends Error{constructor(e="ImmortalDB unexpected error"){super(e),this.name="ImmortalError"}}class o extends r{constructor(e="Unable to encode the value to be stored"){super(e),this.name="ImmortalEncoderError"}}class s extends r{constructor(e="Unable to decode the stored value"){super(e),this.name="ImmortalDecoderError"}}class n extends r{constructor(e="Some stores failed to perform operation"){super(e),this.name="ImmortalStoresPartialError"}}class i extends r{constructor(e="All stores failed to perform operation"){super(e),this.name="ImmortalStoresTotalError"}}function a(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var o in r)e[o]=r[o]}return e}var c=function e(t,r){function o(e,o,s){if("undefined"!=typeof document){"number"==typeof(s=a({},r,s)).expires&&(s.expires=new Date(Date.now()+864e5*s.expires)),s.expires&&(s.expires=s.expires.toUTCString()),e=encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape);var n="";for(var i in s)s[i]&&(n+="; "+i,!0!==s[i]&&(n+="="+s[i].split(";")[0]));return document.cookie=e+"="+t.write(o,e)+n}}return Object.create({set:o,get:function(e){if("undefined"!=typeof document&&(!arguments.length||e)){for(var r=document.cookie?document.cookie.split("; "):[],o={},s=0;s<r.length;s++){var n=r[s].split("="),i=n.slice(1).join("=");try{var a=decodeURIComponent(n[0]);if(o[a]=t.read(i,a),e===a)break}catch(e){}}return e?o[e]:o}},remove:function(e,t){o(e,"",a({},t,{expires:-1}))},withAttributes:function(t){return e(this.converter,a({},this.attributes,t))},withConverter:function(t){return e(a({},this.converter,t),this.attributes)}},{attributes:{value:Object.freeze(r)},converter:{value:Object.freeze(t)}})}({read:function(e){return'"'===e[0]&&(e=e.slice(1,-1)),e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent)},write:function(e){return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,decodeURIComponent)}},{path:"/"});const l=function(){try{return!window.top.location.href}catch(e){return!0}}(),u=!!l,h=l?"None":"Lax";class d{constructor({ttl:e=365,secure:t=u,sameSite:r=h}={}){return this.ttl=e,this.secure=t,this.sameSite=r,(async()=>this)()}async get(e){const t=c.get(e);return"string"==typeof t?t:void 0}async set(e,t){c.set(e,t,this._constructCookieParams())}async remove(e){c.remove(e,this._constructCookieParams())}_constructCookieParams(){return{expires:this.ttl,secure:this.secure,sameSite:this.sameSite}}}function m(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==e.g)return e.g;throw new Error("unable to locate global object")}class f{constructor(e="keyval-store",t="keyval"){this.storeName=t,this._dbp=new Promise(((r,o)=>{const s=indexedDB.open(e,1);s.onerror=()=>o(s.error),s.onsuccess=()=>r(s.result),s.onupgradeneeded=()=>{s.result.createObjectStore(t)}}))}_withIDBStore(e,t){return this._dbp.then((r=>new Promise(((o,s)=>{const n=r.transaction(this.storeName,e);n.oncomplete=()=>o(),n.onabort=n.onerror=()=>s(n.error),t(n.objectStore(this.storeName))}))))}}let p;function w(){return p||(p=new f),p}const _="ImmortalDB",y="key-value-pairs";class v{constructor(e=_,t=y){return this.store=new f(e,t),(async()=>{try{await this.store._dbp}catch(e){if("SecurityError"===e.name)return null;throw e}return this})()}async get(e){const t=await function(e,t=w()){let r;return t._withIDBStore("readonly",(t=>{r=t.get(e)})).then((()=>r.result))}(e,this.store);return"string"==typeof t?t:void 0}async set(e,t){await function(e,t,r=w()){return r._withIDBStore("readwrite",(r=>{r.put(t,e)}))}(e,t,this.store)}async remove(e){await function(e,t=w()){return t._withIDBStore("readwrite",(t=>{t.delete(e)}))}(e,this.store)}}class g{constructor(e){return this.store=e,(async()=>this)()}async get(e){const t=this.store.getItem(e);return"string"==typeof t?t:void 0}async set(e,t){this.store.setItem(e,t)}async remove(e){this.store.removeItem(e)}}class S extends g{constructor(){super(window.localStorage)}}class E extends g{constructor(){super(window.sessionStorage)}}const b=void 0,k="_immortal|",x=[],I=m();try{I&&I.indexedDB&&x.push(v)}catch(e){}try{I&&I.localStorage&&x.push(S)}catch(e){}const P="fulfilled",j=e=>e;class D extends EventTarget{constructor(e=x,t=k,r=b,o=j,s=j){super(),this._encoder=o||j,this._decoder=s||j,this._defaultValue=r,this._keyPrefix=t??k,this._stores=[],this._locks=new Map,this.onReady=(async()=>{const t=await Promise.allSettled(e.map((e=>{if("function"!=typeof e)return e;try{return new e}catch(e){return Promise.reject(e)}})));return this._stores=t.filter((e=>e.status===P)).map((e=>e.value)).filter((e=>e)),0===this._stores.length?Promise.reject(new Error("Unable to construct any store")):Promise.resolve()})()}_createErrorFromSettledPromises(e,t){const r=e.filter((e=>"rejected"===e.status)).map((e=>e.reason instanceof Error?e.reason.message:String(e.reason)));if(r.length>0){const e=this._stores.length===r.length,o=[`${e?"All":"Some"} stores failed to ${t}(). Store errors:`,...r.map((e=>`    * "${e}"`))].join("\n");return new(e?i:n)(o)}}async _lock(e){if(!this._acquireLock(e))return new Promise((t=>{this.addEventListener(e,(function r(){this._acquireLock(e)&&(this.removeEventListener(e,r),t())}))}))}async _unlock(e){this._locks.delete(e),this.dispatchEvent(new Event(e))}_prefix(e){return`${this._keyPrefix}${e}`}_acquireLock(e){return!this._locks.has(e)&&(this._locks.set(e,!0),!0)}async get(e,t=this._defaultValue){await this._lock(e);try{const r=await this._get(e,t);return await this._unlock(e),r}catch(t){throw await this._unlock(e),t}}async _get(e,t=this._defaultValue){await this.onReady;const r=this._prefix(e),n=await Promise.allSettled(this._stores.map((e=>e.get(r)))),i=function(e){let t=0;const r=Object.create(null);e.forEach((e=>{if(null==e)return void(t+=1);const o=r[e]||0;r[e]=o+1}));const o=Object.entries(r);return t&&o.push([void 0,t]),o}(n.filter((e=>e.status===P)).map((e=>e.value)));i.sort(((e,t)=>e[1]<=t[1]));const a=i.filter((([e])=>void 0!==e&&"undefined"!==e));if(0===a.length){return this._createErrorFromSettledPromises(n,"get")||await this._remove(e),t}const[c]=a[0];let l;try{l=await this._decoder(c)}catch(e){throw new s}try{await this._set(e,l)}catch(e){if(e instanceof o)throw e}return l}async set(e,t){await this._lock(e);try{const r=await this._set(e,t);return await this._unlock(e),r}catch(t){throw await this._unlock(e),t}}async _set(e,t){await this.onReady;const r=this._prefix(e);let s;try{s=await this._encoder(t)}catch(e){throw new o}if(void 0===s||"undefined"===s)throw new o('Unable to store encoded value "undefined"');const n=await Promise.allSettled(this._stores.map((e=>e.set(r,s)))),i=this._createErrorFromSettledPromises(n,"set");if(i)throw i;const a=await Promise.allSettled(this._stores.map((e=>e.get(r).then((e=>{if(e&&"undefined"!==e&&e!==s)return Promise.reject(new Error("Integrity check failed"))}))))),c=this._createErrorFromSettledPromises(a,"set");if(c)throw c;return t}async remove(e){await this._lock(e);try{const t=await this._remove(e);return await this._unlock(e),t}catch(t){throw await this._unlock(e),t}}async _remove(e){await this.onReady;const t=this._prefix(e),r=await Promise.allSettled(this._stores.map((e=>e.remove(t)))),o=this._createErrorFromSettledPromises(r,"remove");if(o)throw o;return this._defaultValue}}return t})()));